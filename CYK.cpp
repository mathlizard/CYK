#include <iostream>
#include <vector>
#include <algorithm> // we need std::replace
#include <fstream>
#include <string>
#include <unordered_map>
#include <assert.h>
#include <set>

using namespace std;

// a rewrite rule 'A -> B C' is stored as a vector of strings : "A", "B", "C", ...
typedef vector<string> rule;

typedef set<rule> rules;

// generic Matrix datatype, will be good later too
template <class T>
class Matrix {
private:
	// number of rows
	size_t dim_rows;

	//number of columns
	size_t dim_columns;

	// the data
	T **matrix{ nullptr };

public:
	// rw access to matrix elements
	T& operator()(const size_t &row, const size_t &col) {
		return matrix[row][col];
	}

	// copy assignment operator
	Matrix<T>& operator=(Matrix<T> const &m) {
		size_t j;
		this->~Matrix();
		new (this) Matrix(m.dim_rows, m.dim_columns);
		for (size_t i = 0; i < dim_columns; ++i)
			for (j = 0; j < dim_rows; ++j)
				matrix[j][i] = m.matrix[j][i];
		cerr << "copy assignment operator called" << '\n';
		return *this;
	}

	// move assigment operator
	Matrix<T>& operator=(Matrix<T> &&m) {
		std::swap(this->matrix, m.matrix);
		std::swap(this->dim_columns, m.dim_columns);
		std::swap(this->dim_rows, m.dim_rows);
		cerr << "move assignment operator called" << '\n';
		return *this;
	}

	// constructor without fill value
	Matrix(const size_t &a, const size_t &b) : dim_rows(a), dim_columns(b) {
		assert(a > 0 && b > 0);
		matrix = new T*[dim_columns];
		for (size_t i = 0; i < dim_columns; ++i)
			matrix[i] = new (nothrow) T[dim_rows];
		cerr << "constructor called" << '\n';
	}

	// constructor fills the matrix with fill_value
	Matrix(const size_t &a, const size_t &b, const T &fill_value) : Matrix(a, b) {
		size_t j;
		for (size_t i = 0; i < dim_columns; ++i)
			for (j = 0; j < dim_rows; ++j)
				matrix[j][i] = fill_value;
		cerr << "constructor called with fill_value" << '\n';
	}

	// default constructor
	Matrix() : dim_rows(0), dim_columns(0) {}

	// move constructor
	Matrix(Matrix<T> &&m) {
		std::swap(this->matrix, m.matrix);
		std::swap(this->dim_columns, m.dim_columns);
		std::swap(this->dim_rows, m.dim_rows);
		cerr << "move constructor called" << '\n';
	}

	bool empty() {
		return (matrix == nullptr);
	}

	// destructor
	~Matrix() {
		if (matrix != nullptr) {
			for (size_t i = 0; i < dim_columns; ++i)
				delete matrix[i];
			delete[] matrix;
			matrix = nullptr;
			cerr << "destructor called" << '\n';
		}
	}
};

// splits 's' into tokens, copies them into 'tokens_of_s'
void split(string s, const string &delimiter, vector<string> &tokens_of_s) {
	size_t pos{ 0 };
	while ((pos = s.find(delimiter)) != string::npos) {
		tokens_of_s.push_back(s.substr(0, pos));
		s.erase(0, pos + delimiter.length());
	}
	tokens_of_s.push_back(s);
}

// reads from 'file' one line at a time into 'into_this'
bool read_from_file(const string &file, vector<string> &into_this){
	string line;
	ifstream input(file);
	if (input.is_open()) {
		while (getline(input, line))
			into_this.push_back(line);
		input.close();
	} else {
		cerr << "Unable to open file " << file << "\n";
	 return false;
	}
 return true;
}

/* This is the CYK algorithm. Dynamic programming 
       with running time O( size_of_string_to_parse^3 * size_of_grammar ).

   Parameters:
   -----------
    'nonterminal_rules' are of the form 
                               A -> B C
    'terminal rules' are of the form 
                               A -> a
    'starting_symbol' is the starting symbol of the grammar,
    'nonterminals' contains the nonterminal symbols.

	Return value:
	-------------
	 'true' iff 's' belongs to the language generated by the grammar
*/
bool CYK(const rules &nonterminal_rules, const rules &terminal_rules, const string &s, 
	     const string &starting_symbol, const set<string> &nonterminals) { 
	size_t i, j, k;
	size_t n{ s.length() };
	unordered_map< string, Matrix<bool> > M;

	for (const auto &i : nonterminals)
		M[i] = Matrix<bool>(n, n, false);

	for (const auto &v : terminal_rules)
		for (i = 0; i < n; ++i)
			if (string(1,s[i]) == v[1])
				M[v[0]](i, i) = true;

	for (j = 1; j < n; ++j)
		for (i = 0; i + j < n; ++i)
			for (const auto &v : nonterminal_rules)
				for (k = i; k < i + j; ++k)
					if (M[v[1]](i, k) && M[v[2]](k + 1, i + j)){
						M[v[0]](i, i + j) = true;
						break;
					}
	return M[starting_symbol](0, n - 1);
}

// true iff 's' occurs in 'in_this'
inline bool is_in(const string &s, const set<string> &in_this) {
	return (in_this.find(s) != in_this.end());
}

// decomposes a rule (A -> B C D E ...) into the rules (A -> B#C#D E), (B#C#D -> B#C D), (B#C -> B C), ... respectively.
// might expand 'nonterminals'
// might rewrite 'rule_to_decompose'
void decompose(rule &rule_to_decompose, set<string> &nonterminals, rules &decomposed_rules) {
	string temp;
	if (rule_to_decompose.size() == 2) {
		if (is_in(rule_to_decompose[1], nonterminals)) {
			cerr << " ERROR : irregular occurence of chain rule (i.e. A -> B)! - ignored " << '\n';
			return;
		} else
			decomposed_rules.insert(rule_to_decompose);
	} else {
		for (size_t i = 1; i<rule_to_decompose.size();++i)
			if (!is_in(rule_to_decompose[i], nonterminals)) {
				temp = "#" + rule_to_decompose[i];
				nonterminals.insert(temp);
				decomposed_rules.insert(rule{ temp, rule_to_decompose[i] });
				replace(rule_to_decompose.begin() + i, rule_to_decompose.end(), rule_to_decompose[i], temp);
			}
		while(rule_to_decompose.size() > 3) {
			temp = rule_to_decompose[1] + "#" + rule_to_decompose[2];
			nonterminals.insert(temp);
			decomposed_rules.insert(rule{ temp, rule_to_decompose[1], rule_to_decompose[2] });
			rule_to_decompose[1] = temp;
			rule_to_decompose.erase(rule_to_decompose.begin() + 2);
		}
		decomposed_rules.insert(rule_to_decompose);
	}
}

int main() {
	ofstream output;
	string starting_symbol;
	vector<string> strings_to_parse;
	vector<string> derivation_rules;
	vector<string> tokens_of_line;
	vector<string> rhs;
	vector<string> nonterminals_vec;
	set<string> nonterminals;
	rule r;
	rules terminal_rules;
	rules nonterminal_rules;
	rules rule_set;
	// 
	// the input of this algorithm is a context free grammar in Chomsky-normal form
	// ----------------------------------------------------------------------------
	// derivation_rules.txt : each line looks like 'A -> B C D ...' or 'A -> a b c ...'
	// nonterminals.txt : each line is a nonterminal, for ex. 'A'
	// strings_to_parse.txt : each line contains a string to parse
	// 
	if ( (read_from_file("derivation_rules.txt", derivation_rules) && 
		  read_from_file("nonterminals.txt", nonterminals_vec)) &&
	      read_from_file("strings_to_parse.txt", strings_to_parse) ) {

		// 'starting_symbol' is in the first line of 'nonterminals.txt'
		starting_symbol = nonterminals_vec.front();     
		
		// convert the nonterminals into a set
		nonterminals = set<string>( std::make_move_iterator(nonterminals_vec.begin()), 
								    std::make_move_iterator(nonterminals_vec.end()) );
		
		for (const auto &line : derivation_rules) {		// parsing 'line' we build 'r'
			split(line, "->", tokens_of_line);			// lhs is 'tokens_of_line[0]', rhs is 'tokens_of_line[1]'
			split(tokens_of_line[1], " ", rhs);
			r.push_back(tokens_of_line[0]);				// put lhs into 'r'
			for (const auto &x : rhs)
				r.push_back(x);							// put rhs into 'r', one by one
			decompose(r, nonterminals, rule_set);		// transform r into chomsky nf, put the resulting rules into temp
			r.clear();
			rhs.clear();
			tokens_of_line.clear();
		}

		for (const auto &r : rule_set)
			if (r.size() == 2)							// if the rule is terminal, i.e. A -> a
				terminal_rules.insert(r);
			else										// otherwise, i.e. when it's A -> B C
				nonterminal_rules.insert(r);

		rule_set.clear();
		
		// At this point the rules are already loaded into 'terminal_rules' and 'nonterminal rules', respectively.
		// Below we go over each line of strings_to_parse, and we output whether it belongs to the language
		// generated by the grammar.

		output.open("output.txt");

		if (output.is_open()){
			for(const auto &s : strings_to_parse)
				output << CYK(nonterminal_rules, terminal_rules, s, starting_symbol, nonterminals) << '\n';
		} else {
			cerr << "Unable to open output.txt" << '\n';
		}
	}
 return 0;
}
